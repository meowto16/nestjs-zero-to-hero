# Введение в NestJS пайпы

- Пайпы работают над обработкой аргументов, которые были переданы в обработчик
роута, до того как обработчик был вызван
- Пайпы могут выполнять `data transformation` или `data validation`. Короче говоря,
трансформировать и валидировать данные
- Пайпы могут возвращать данные — либо оригинальные, либо модифицированные - которые
будут переданы в обработчик роута.
- Пайпы могут выбрасывать exception'ы. Выброшенные exception'ы будут обработаны NestJS
и спарсятся в ответ с ошибкой
- Пайпы могут быть асинхронными

NestJS имеет несколько полезных пайпов внутри `@nestjs/common` модуля.

> ### ValidationPipe
> 
> Валидирует совместимость полного объекта с классом (хорошо работает с DTO)
> Если какое-либо из свойств не может правильно сопоставиться (например, неправильный тип) - валидация упадет.
> 
> Самый обычный кейс, поэтому встроенные пайпы валидации - очень полезны

> ### ParseIntPipe
> По стандарту аргументы являются типом String. Этот пайп валидирует аргументы - проверяя число ли это.
> 
> Если да, аргумент трансформируется в Number и передается в обработчик
> 
> Очень полезен, когда вы ожидаете число в обработчике, и не хотите тратить время на перевод аргумента в Int

## Кастомный пайпы, имплементация

- Пайпы являются классами, которые аннотированы с `@Injectable` декоратором
- Пайпы должны реализовывать `PipeTransform` интерфейс. Следовательно, каждый
пайп должен иметь `transform()` метод. Этот метод будет вызываться NestJS, при передаче
  в аргументы
- `transform()` метод принимает два параметры
  - `value` - значение передаваемого аргумента
  - `metadata (optional)` - объект, содержащий метаданные о аргументе
- Все что будет возвращаться из `transform()` метода - будет передано в аргументы обработчика роута.
Исключения будут выброшены клиенту.
- Пайпы могут использоваться по разному

- **Handler-level pipes** - объявляются на уровне обработчика с помощью `@UsePipes()` декоратора.
 Такой пайп обработает все параметры во входящем запросе.
```typescript
@Post()
@UsePipes(SomePipe)
createTask(
  @Body('description') description
) {
  // ...
}
```
- **Parameter-level pipes** - объявляются на уровне аргументов. Только для определенного параметра,
пайп обработает только его.
```typescript
@Post()
createTask(
  @Body('description', SomePipe) description
) {
  // ...
}
```
- **Global pipes** объявляются на уровне приложения и будут применены к любому входящему запросу
```typescript
async function bootstrap() {
  const app = await NestFactory.create(ApplicationModule)
  app.useGlobalPipes(SomePipe)
  await app.listen(3000)
}
boostrap()
```

## Parameter-level или Handler-level пайпы? Какие выбрать?

По-разному.

**Parameter-level pipes** обычно тоньше и чище. Тем не менее, они часто являются результатом
лишнего кода, добавленного в обработчики - что может к грязи и сложности поддержки

**Handler-level pipes** - требуются чуть больше кода, но имею свои очевидные плюсы

- Такие пайпы не требуют лишнего кода на уровне аргументов
- Легче поддерживать и расширять. Если форма данных изменится, проще произвести изменения внутри лишь одного пайпа
- Ответственность за определение аргументов, которые можно обработать смещается к одному центральному файлу - пайп файлу
- Способствует использованию DTO, что является очень хорошей практикой

## Путь запроса

![1. Путь запроса](./img/1.%20Way%20of%20the%20request.png)
